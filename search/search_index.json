{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"frac_blp","text":"<p>FRAC for macro-BLP (Salanie-Wolak).</p> <ul> <li>Github repository: https://github.com/bsalanie/frac-blp/</li> <li>Documentation https://bsalanie.github.io/frac-blp/</li> </ul>"},{"location":"index.html#overview","title":"Overview","text":"<p>The package estimates a second-order approximation to the macro BLP model with random coefficients using the FRAC method of Salanie and Wolak. </p> <p>At this early stage, the package only implements the basic version of the model without demographics. </p> <p>The user should be familiar with the macro BLP model (Berry, Levinsohn, and Pakes, 1995). We use very similar notation to that of Conlon and Gortmaker in their <code>pyblp</code> package:</p> <p>The inputs are: * <code>T</code>: the number of markets  * <code>J</code>: the number of products per market * <code>X1</code>: variables with fixed coefficients, an <code>(N=T*J, n1)</code> matrix * <code>X2</code>: variables with random coefficients, an <code>(N, n2)</code> matrix * <code>Z</code>: instruments, an <code>(N, nz)</code> matrix.</p> <p>The outputs are: * <code>betas</code>: the coefficients on the variables with fixed coefficients and the mean coefficients on the variables with random coefficients, an <code>(n1 + n2)</code> vector * <code>sigmas</code>: the standard deviations of the coefficients on the variables with random coefficients, an <code>n2</code> vector.</p>"},{"location":"index.html#entering-the-data","title":"entering the data","text":"<p>The user must provide the data as numpy arrays with <code>T*J</code> rows:</p> <ul> <li> <p><code>X1_exo, X1_endo, X2_exo, X2_endo</code>: matrices of exogenous and endogenous variables with fixed and random coefficients</p> </li> <li> <p><code>Z</code>: matrix of instruments</p> </li> <li> <p><code>shares</code>: vector of market shares.</p> </li> </ul> <p>The observations should be ordered by market, i.e., the first <code>J</code> rows correspond to market 1, the next <code>J</code> rows to market 2, etc.</p> <p>These are entered in the model as follows: <pre><code>rom frac blp.frac classes import FracNodemogRealData\n\nfrac data = FracNodemogRealData(T, J,\n                            X1_exo, X1_endo,\n                            X2_exo, X2_endo,\n                            Z, shares,\n                            names_vars_beta,\n                            names_vars_sigma)\n</code></pre> Then the model can be estimated with: <pre><code>from frac_blp.frac_nodemog import estimate\n\nbetabar, sigmas = frac nodemog estimate(frac data)\n</code></pre></p>"},{"location":"index.html#release-notes","title":"Release notes","text":""},{"location":"index.html#02-october-27-2025","title":"0.2 (October 27, 2025)","text":"<p>Improved README.</p>"},{"location":"index.html#01-october-26-2025","title":"0.1 (October 26, 2025)","text":"<p>First working version, no demographics.</p>"},{"location":"artificial_regressors.html","title":"artificial_regressors module","text":"<p>Helpers to construct Salani\u00e9-Wolak artificial regressors.</p>"},{"location":"artificial_regressors.html#frac_blp.artificial_regressors.make_K","title":"<code>make_K(X, shares)</code>","text":"<p>Build second-order Salani\u00e9-Wolak artificial regressors.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Product characteristics of shape <code>(n_products, n_x)</code>.</p> required <code>shares</code> <code>ndarray</code> <p>Product-level market shares of shape <code>(n_products,)</code>.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Matrix <code>K</code> with shape <code>(n_products, n_x)</code>.</p> Source code in <code>frac_blp/artificial_regressors.py</code> <pre><code>def make_K(X: np.ndarray, shares: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Build second-order Salani\u00e9-Wolak artificial regressors.\n\n    Args:\n        X (np.ndarray): Product characteristics of shape ``(n_products, n_x)``.\n        shares (np.ndarray): Product-level market shares of shape ``(n_products,)``.\n\n    Returns:\n        np.ndarray: Matrix ``K`` with shape ``(n_products, n_x)``.\n    \"\"\"\n    eS_X = X.T @ shares\n    djm = eS_X - X / 2.0\n    return cast(np.ndarray, -djm * X)\n</code></pre>"},{"location":"artificial_regressors.html#frac_blp.artificial_regressors.make_K_and_y","title":"<code>make_K_and_y(X2, shares, J)</code>","text":"<p>Construct second-order regressors and the log-share LHS by market.</p> <p>Parameters:</p> Name Type Description Default <code>X2</code> <code>ndarray</code> <p>Regressors with random coefficients.</p> required <code>shares</code> <code>ndarray</code> <p>Observed market shares.</p> required <code>J</code> <code>int</code> <p>Number of products per market.</p> required <p>Returns:</p> Name Type Description <code>TwoArrays</code> <code>TwoArrays</code> <p><code>(K, y)</code> where <code>K</code> are artificial regressors and <code>y</code> is the</p> <code>TwoArrays</code> <p>stacked log share ratios.</p> Source code in <code>frac_blp/artificial_regressors.py</code> <pre><code>def make_K_and_y(X2: np.ndarray, shares: np.ndarray, J: int) -&gt; TwoArrays:\n    \"\"\"\n    Construct second-order regressors and the log-share LHS by market.\n\n    Args:\n        X2 (np.ndarray): Regressors with random coefficients.\n        shares (np.ndarray): Observed market shares.\n        J (int): Number of products per market.\n\n    Returns:\n        TwoArrays: ``(K, y)`` where ``K`` are artificial regressors and ``y`` is the\n        stacked log share ratios.\n    \"\"\"\n    n_obs = X2.shape[0]\n    n_x2 = X2.shape[1]\n    K = np.zeros((n_obs, n_x2))  # the artificial Salanie-Wolak regressors\n    y = np.zeros(n_obs)  # and the regression LHS\n\n    for t in range(n_obs // J):\n        this_market = slice(t * J, (t + 1) * J)\n        these_shares = shares[this_market]\n        sum_shares = these_shares.sum()\n        this_market_zero_share = 1.0 - sum_shares\n        this_X2 = X2[this_market, :]\n\n        # artificial regressors and LHS for Salanie-Wolak\n        K[this_market, :] = make_K(this_X2, these_shares)\n        y[this_market] = np.log(these_shares / this_market_zero_share)\n    return K, y\n</code></pre>"},{"location":"example_frac_nodemog.html","title":"examples/example_frac_nodemog module","text":"<p>Executable example demonstrating FRAC estimation without demographics.</p>"},{"location":"example_frac_nodemog.html#frac_blp.examples.example_frac_nodemog.run_example","title":"<code>run_example()</code>","text":"<p>Run the FRAC estimation example on simulated data.</p> Source code in <code>frac_blp/examples/example_frac_nodemog.py</code> <pre><code>def run_example():\n    \"\"\"Run the FRAC estimation example on simulated data.\"\"\"\n    print_stars(\"Hello from fracblp!\")\n    params = FracNoDemogSimulationParameters(\n        T=100,\n        J=10,\n        n_X1_endo=2,\n        n_X2_endo=2,\n        n_Z=3,\n        betas=np.array([-4.0, 0.5, -0.5]),\n        rho_x_z=0.5,\n        sigmas=np.array([0.7, 0.6]),\n    )\n    simulated_frac_data = simulate_frac_nodemog_data(params)\n    print_stars(\"Simulated Data:\")\n    print(simulated_frac_data)\n\n    print_stars(\"Estimating with FRAC\")\n    _, _ = frac_nodemog_estimate(simulated_frac_data, degree_Z=3, degree_X1=3)\n\n    print_stars(\"Example with the real data interface:\")\n    real_frac_data = FracNoDemogRealData(\n        T=simulated_frac_data.T,\n        J=simulated_frac_data.J,\n        X1_exo=simulated_frac_data.X1_exo,\n        X1_endo=simulated_frac_data.X1_endo,\n        X2_exo=simulated_frac_data.X2_exo,\n        X2_endo=simulated_frac_data.X2_endo,\n        Z=simulated_frac_data.Z,\n        shares=simulated_frac_data.shares,\n        names_vars_beta=simulated_frac_data.names_vars_beta,\n        names_vars_sigma=simulated_frac_data.names_vars_sigma,\n    )\n    print_stars(\"Estimating with FRAC\")\n    _, _ = frac_nodemog_estimate(real_frac_data, degree_Z=3, degree_X1=3)\n</code></pre>"},{"location":"frac_classes.html","title":"frac_classes module","text":"<p>Data containers used by FRAC estimators.</p>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogRealData","title":"<code>FracNoDemogRealData</code>","text":"<p>               Bases: <code>_FracNoDemogBase</code></p> <p>Container for real FRAC data without demographics.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>class FracNoDemogRealData(_FracNoDemogBase):\n    \"\"\"Container for real FRAC data without demographics.\"\"\"\n\n    shares: np.ndarray\n\n    @field_validator(\"shares\", mode=\"before\")\n    @classmethod\n    def _coerce_shares(cls, value: np.ndarray) -&gt; np.ndarray:\n        shares = np.asarray(value).squeeze()\n        return shares\n\n    @model_validator(mode=\"after\")\n    def _validate_shares(self) -&gt; \"FracNoDemogRealData\":\n        shares = self.shares\n        if shares.ndim != 1:\n            raise ValueError(\"shares must be a 1D array.\")\n        if shares.shape[0] != self.n_obs:\n            raise ValueError(\n                f\"shares must have length {self.n_obs} (got {shares.shape[0]}).\"\n            )\n        if not np.all(np.isfinite(shares)):\n            raise ValueError(\"shares must contain only finite values.\")\n        if np.any((shares &lt; 0.0) | (shares &gt; 1.0)):\n            raise ValueError(\"shares must lie between 0 and 1.\")\n        T, J = self.T, self.J\n        for t in range(T):\n            market_shares = shares[t * J : (t + 1) * J]\n            if market_shares.sum() &gt; 1.0:\n                raise ValueError(\n                    f\"Shares in market {t} sum to more than 1 (got {market_shares.sum():.4f}).\"\n                )\n        return self\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a text summary of the observed dataset.\n\n        Returns:\n            str: Multi-line description with key parameters.\n        \"\"\"\n        desc = \"Observed Data for FRAC w/o demographics:\\n\"\n        desc += f\"  Number of markets (T): {self.T}\\n\"\n        desc += f\"  Products per market (J): {self.J}\\n\"\n        desc += (\n            f\"  Names of variables with fixed coefficients: {self.names_vars_beta}\\n\"\n        )\n        desc += (\n            f\"  Names of variables with random coefficients: {self.names_vars_sigma}\\n\"\n        )\n        return desc\n</code></pre>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogRealData.__str__","title":"<code>__str__()</code>","text":"<p>Return a text summary of the observed dataset.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Multi-line description with key parameters.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return a text summary of the observed dataset.\n\n    Returns:\n        str: Multi-line description with key parameters.\n    \"\"\"\n    desc = \"Observed Data for FRAC w/o demographics:\\n\"\n    desc += f\"  Number of markets (T): {self.T}\\n\"\n    desc += f\"  Products per market (J): {self.J}\\n\"\n    desc += (\n        f\"  Names of variables with fixed coefficients: {self.names_vars_beta}\\n\"\n    )\n    desc += (\n        f\"  Names of variables with random coefficients: {self.names_vars_sigma}\\n\"\n    )\n    return desc\n</code></pre>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogSimulatedData","title":"<code>FracNoDemogSimulatedData</code>","text":"<p>               Bases: <code>_FracNoDemogBase</code></p> <p>Container for simulated FRAC data without demographics.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>class FracNoDemogSimulatedData(_FracNoDemogBase):\n    \"\"\"Container for simulated FRAC data without demographics.\"\"\"\n\n    xi_var: np.ndarray\n    betas: np.ndarray\n    sigmas: np.ndarray\n\n    _shares_cache: np.ndarray | None = PrivateAttr(default=None)\n\n    @field_validator(\"xi_var\", \"betas\", \"sigmas\", mode=\"before\")\n    @classmethod\n    def _coerce_vector(cls, value: np.ndarray) -&gt; np.ndarray:\n        # Coerce to a 1-D array; avoid squeeze creating 0-D for 1x1 inputs.\n        return np.asarray(value).ravel()\n\n    @model_validator(mode=\"after\")\n    def _validate_simulated(self) -&gt; \"FracNoDemogSimulatedData\":\n        n_obs = self.n_obs\n        # print(f\"{n_obs=}, {self.betas=}, {self.sigmas=}\")\n\n        if self.xi_var.ndim != 1 or self.xi_var.shape[0] != n_obs:\n            raise ValueError(f\"xi_var must be a 1D array of length {n_obs}.\")\n\n        if not np.all(np.isfinite(self.xi_var)):\n            raise ValueError(\"xi_var must contain only finite values.\")\n\n        n_x1 = self.X1.shape[1]\n        if self.betas.ndim != 1 or self.betas.shape[0] != n_x1:\n            raise ValueError(\n                \"betas must be a 1D array whose length matches X1's columns.\"\n            )\n\n        n_x2 = self.X2.shape[1]\n        if self.sigmas.ndim != 1 or self.sigmas.shape[0] != n_x2:\n            # print(f\"{self.sigmas.shape=}, {n_x2=}\")\n            raise ValueError(\n                \"sigmas must be a 1D array whose length matches X2's columns.\"\n            )\n\n        if np.any(self.sigmas &lt; 0.0):\n            raise ValueError(\"sigmas must be non-negative.\")\n\n        if not np.all(np.isfinite(self.betas)):\n            raise ValueError(\"betas must contain only finite values.\")\n\n        if not np.all(np.isfinite(self.sigmas)):\n            raise ValueError(\"sigmas must contain only finite values.\")\n\n        return self\n\n    @computed_field(return_type=np.ndarray)  # type: ignore[misc]\n    @property\n    def shares(self) -&gt; np.ndarray:\n        \"\"\"Simulated market shares using sparse Gaussian quadrature.\"\"\"\n        if self._shares_cache is None:\n            self._shares_cache = self.compute_shares()\n        return self._shares_cache\n\n    def compute_shares(self) -&gt; np.ndarray:\n        \"\"\"\n        Simulate market shares via sparse Gaussian quadrature.\n\n        Returns:\n            np.ndarray: Simulated shares stacked across all markets.\n        \"\"\"\n        T, J = self.T, self.J\n        sigmas = self.sigmas\n        sigma = sigmas[0]\n        n_obs = T * J\n        X2 = self.X2\n        n_x2 = X2.shape[1]\n        mean_utils = self.X1 @ self.betas + self.xi_var.reshape(n_obs)\n        shares = np.zeros(n_obs)\n        nodes, weights = setup_sparse_gaussian(n_x2, 17)\n        nodes_T = nodes.T\n        zero_share = np.zeros(self.T)\n        for t in range(T):\n            this_market = slice(t * J, (t + 1) * J)\n            these_mean_utils = mean_utils[this_market]\n            this_X2 = X2[this_market, :]\n\n            def shares_random(eps_vals):\n                randoms = sigma * np.outer(this_X2, eps_vals)\n                randoms = this_X2 @ (nodes_T * sigmas.reshape((-1, 1)))\n                random_utils = randoms + these_mean_utils.reshape((-1, 1))\n                max_util = np.max(random_utils, axis=0)\n                shifted_utils = random_utils - max_util\n                exp_utils = np.exp(shifted_utils)\n                denom = np.exp(-max_util) + np.sum(exp_utils, axis=0)\n                return exp_utils / denom\n\n            shares[this_market] = shares_random(nodes) @ weights\n            zero_share[t] = 1.0 - shares[this_market].sum()\n\n        print_stars(\n            dedent(\n                f\"\"\"\n                    Data generation completed; the average zero share is {zero_share.mean():.4f}\n                    \"\"\"\n            )\n        )\n        return shares\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a text summary of the simulated dataset.\n\n        Returns:\n            str: Multi-line description with key parameters.\n        \"\"\"\n        desc = \"Simulated Data for FRAC w/o demographics:\\n\"\n        desc += f\"  Number of markets (T): {self.T}\\n\"\n        desc += f\"  Products per market (J): {self.J}\\n\"\n        desc += (\n            f\"  Names of variables with fixed coefficients: {self.names_vars_beta}\\n\"\n        )\n        desc += (\n            f\"  Names of variables with random coefficients: {self.names_vars_sigma}\\n\"\n        )\n        desc += f\"  Betas: {self.betas}\\n\"\n        desc += f\"  Sigmas: {self.sigmas}\\n\"\n        return desc\n</code></pre>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogSimulatedData.shares","title":"<code>shares</code>  <code>property</code>","text":"<p>Simulated market shares using sparse Gaussian quadrature.</p>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogSimulatedData.__str__","title":"<code>__str__()</code>","text":"<p>Return a text summary of the simulated dataset.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Multi-line description with key parameters.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return a text summary of the simulated dataset.\n\n    Returns:\n        str: Multi-line description with key parameters.\n    \"\"\"\n    desc = \"Simulated Data for FRAC w/o demographics:\\n\"\n    desc += f\"  Number of markets (T): {self.T}\\n\"\n    desc += f\"  Products per market (J): {self.J}\\n\"\n    desc += (\n        f\"  Names of variables with fixed coefficients: {self.names_vars_beta}\\n\"\n    )\n    desc += (\n        f\"  Names of variables with random coefficients: {self.names_vars_sigma}\\n\"\n    )\n    desc += f\"  Betas: {self.betas}\\n\"\n    desc += f\"  Sigmas: {self.sigmas}\\n\"\n    return desc\n</code></pre>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogSimulatedData.compute_shares","title":"<code>compute_shares()</code>","text":"<p>Simulate market shares via sparse Gaussian quadrature.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Simulated shares stacked across all markets.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>def compute_shares(self) -&gt; np.ndarray:\n    \"\"\"\n    Simulate market shares via sparse Gaussian quadrature.\n\n    Returns:\n        np.ndarray: Simulated shares stacked across all markets.\n    \"\"\"\n    T, J = self.T, self.J\n    sigmas = self.sigmas\n    sigma = sigmas[0]\n    n_obs = T * J\n    X2 = self.X2\n    n_x2 = X2.shape[1]\n    mean_utils = self.X1 @ self.betas + self.xi_var.reshape(n_obs)\n    shares = np.zeros(n_obs)\n    nodes, weights = setup_sparse_gaussian(n_x2, 17)\n    nodes_T = nodes.T\n    zero_share = np.zeros(self.T)\n    for t in range(T):\n        this_market = slice(t * J, (t + 1) * J)\n        these_mean_utils = mean_utils[this_market]\n        this_X2 = X2[this_market, :]\n\n        def shares_random(eps_vals):\n            randoms = sigma * np.outer(this_X2, eps_vals)\n            randoms = this_X2 @ (nodes_T * sigmas.reshape((-1, 1)))\n            random_utils = randoms + these_mean_utils.reshape((-1, 1))\n            max_util = np.max(random_utils, axis=0)\n            shifted_utils = random_utils - max_util\n            exp_utils = np.exp(shifted_utils)\n            denom = np.exp(-max_util) + np.sum(exp_utils, axis=0)\n            return exp_utils / denom\n\n        shares[this_market] = shares_random(nodes) @ weights\n        zero_share[t] = 1.0 - shares[this_market].sum()\n\n    print_stars(\n        dedent(\n            f\"\"\"\n                Data generation completed; the average zero share is {zero_share.mean():.4f}\n                \"\"\"\n        )\n    )\n    return shares\n</code></pre>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogSimulationParameters","title":"<code>FracNoDemogSimulationParameters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters used in FRAC data simulation.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>class FracNoDemogSimulationParameters(BaseModel):\n    \"\"\"Parameters used in FRAC data simulation.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    T: int\n    J: int\n    n_X1_exo: int = 0\n    n_X1_endo: int = 1\n    n_X2_exo: int = 0\n    n_X2_endo: int = 1\n    n_Z: int = 1\n    sigma_x: float = 1.0\n    sigma_xi: float = 1.0\n    rho_xz: float = float(np.sqrt(0.5))\n    rho_x_xi: float = float(np.sqrt(0.5))\n    betas: np.ndarray = np.array([-4.3, 1.0])\n    sigmas: np.ndarray = np.array([1.0])\n    names_vars_beta: list[str] = [\"constant\", \"x\"]\n    names_vars_sigma: list[str] = [\"x\"]\n\n    @field_validator(\n        \"T\", \"J\", \"n_X1_exo\", \"n_X1_endo\", \"n_X2_exo\", \"n_X2_endo\", mode=\"before\"\n    )\n    @classmethod\n    def _validate_positive_int(cls, value: int) -&gt; int:\n        if value &lt;= 0:\n            raise ValueError(\"T and J must be strictly positive integers.\")\n        return int(value)\n\n    @field_validator(\"betas\", \"sigmas\", mode=\"before\")\n    @classmethod\n    def _coerce_vector(cls, value: np.ndarray) -&gt; np.ndarray:\n        # Coerce to a 1-D array; avoid squeeze creating 0-D for 1x1 inputs.\n        return np.asarray(value).ravel()\n\n    @field_validator(\"sigma_xi\")\n    @classmethod\n    def _validate_sigma_xi(cls, v: float):\n        if not np.isfinite(v):\n            raise ValueError(\"sigma_xi must be finite.\")\n        if v &lt; 0.0:\n            raise ValueError(\"sigma_xi must be non-negative.\")\n        return float(v)\n\n    @model_validator(mode=\"after\")\n    def _validate_betas_length(self) -&gt; \"FracNoDemogSimulationParameters\":\n        expected_n1 = 1 + int(self.n_X1_exo) + int(self.n_X1_endo)\n        if self.betas.ndim != 1:\n            raise ValueError(\"betas must be a 1D array.\")\n        if self.betas.shape[0] != expected_n1:\n            raise ValueError(\n                f\"betas must have length 1 + n_X1_exo + n_X1_endo = {expected_n1} (got {self.betas.shape[0]}).\"\n            )\n        return self\n\n    @model_validator(mode=\"after\")\n    def _validate_sigmas_length(self) -&gt; \"FracNoDemogSimulationParameters\":\n        expected_n2 = int(self.n_X2_exo) + int(self.n_X2_endo)\n        if self.sigmas.ndim != 1:\n            raise ValueError(\"sigmas must be a 1D array.\")\n        if self.sigmas.shape[0] != expected_n2:\n            raise ValueError(\n                f\"sigmas must have length n_X2_exo + n_X2_endo = {expected_n2} (got {self.sigmas.shape[0]}).\"\n            )\n        return self\n\n    @model_validator(mode=\"after\")\n    def _validate_dimensions_relationships(self) -&gt; \"FracNoDemogSimulationParameters\":\n        if int(self.n_X2_exo) &gt; int(self.n_X1_exo):\n            raise ValueError(\"n_X2_exo must be less than or equal to n_X1_exo.\")\n        if int(self.n_X2_endo) &gt; int(self.n_X1_endo):\n            raise ValueError(\"n_X2_endo must be less than or equal to n_X1_endo.\")\n        if int(self.n_Z) &lt; int(self.n_X1_endo):\n            raise ValueError(\"n_Z must be greater than or equal to n_X1_endo.\")\n        return self\n\n    @field_validator(\"sigmas\")\n    @classmethod\n    def _validate_sigmas_nonneg(cls, v: np.ndarray) -&gt; np.ndarray:\n        if not np.all(np.isfinite(v)):\n            raise ValueError(\"sigmas must contain only finite values.\")\n        if np.any(v &lt; 0.0):\n            raise ValueError(\"all components of sigmas must be non-negative.\")\n        return v\n\n    @field_validator(\"rho_xz\", \"rho_x_xi\")\n    @classmethod\n    def _validate_rho(cls, v: float, info):\n        if not np.isfinite(v):\n            raise ValueError(f\"{info.field_name} must be finite.\")\n        if v &lt; -1.0 or v &gt; 1.0:\n            raise ValueError(f\"{info.field_name} must be between -1 and 1.\")\n        return float(v)\n</code></pre>"},{"location":"frac_nodemog.html","title":"frac_nodemog module","text":"<p>FRAC estimation on macro-BLP, without demographics</p>"},{"location":"frac_nodemog.html#frac_blp.frac_nodemog.frac_nodemog_estimate","title":"<code>frac_nodemog_estimate(frac_data, degree_Z=2, degree_X1=2)</code>","text":"<p>Estimate FRAC parameters without demographics using two-stage least squares.</p> <p>Parameters:</p> Name Type Description Default <code>frac_data</code> <code>FracNoDemogData</code> <p>Data container with regressors, instruments, and simulated or empirical shares.</p> required <code>degree_Z</code> <code>int</code> <p>Degree of polynomial expansion for instruments. Default is 2.</p> <code>2</code> <code>degree_X1</code> <code>int</code> <p>Degree of polynomial expansion for exogenous regressors in X1. Default is 2.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>TwoArrays</code> <code>TwoArrays</code> <p>Tuple <code>(betas_est, sigmas_est)</code> with fixed and random coefficient</p> <code>TwoArrays</code> <p>estimates, respectively.</p> Source code in <code>frac_blp/frac_nodemog.py</code> <pre><code>def frac_nodemog_estimate(\n    frac_data: FracNoDemogData,\n    degree_Z: int = 2,\n    degree_X1: int = 2,\n) -&gt; TwoArrays:\n    \"\"\"\n    Estimate FRAC parameters without demographics using two-stage least squares.\n\n    Args:\n        frac_data (FracNoDemogData): Data container with regressors, instruments, and\n            simulated or empirical shares.\n        degree_Z (int): Degree of polynomial expansion for instruments. Default is 2.\n        degree_X1 (int): Degree of polynomial expansion for exogenous regressors in X1.\n            Default is 2.\n\n    Returns:\n        TwoArrays: Tuple ``(betas_est, sigmas_est)`` with fixed and random coefficient\n        estimates, respectively.\n    \"\"\"\n    X1_exo = frac_data.X1_exo\n    X1, X2 = frac_data.X1, frac_data.X2\n    J = frac_data.J\n    Z = frac_data.Z\n    names_vars_beta = frac_data.names_vars_beta\n    names_vars_sigma = frac_data.names_vars_sigma\n    shares = frac_data.shares\n    K, y = make_K_and_y(X2, shares, J)\n    n_x1 = X1.shape[1]\n    n_x2 = X2.shape[1]\n\n    # combine exogenous regressors and instruments\n    Z_full = make_Z_full(Z, X1_exo, degree_Z=degree_Z, degree_X1=degree_X1)\n\n    # project on the full set of instruments\n    y_hat, _, r2_y = proj_Z_full(y.reshape((-1, 1)), Z_full)\n    K_hat, _, r2_K = proj_Z_full(K, Z_full)\n    X1_hat, _, r2_X1 = proj_Z_full(X1, Z_full)\n\n    print_stars(f\"The first stage R2s are (using {Z_full.shape[1]} instruments):\")\n    print(f\"     y: {r2_y[0]:.3f}\")\n    for ix in range(n_x1):\n        print(f\"     {names_vars_beta[ix]}: {r2_X1[ix]:.3f}\")\n    for ix in range(n_x2):\n        print(f\"     K_{names_vars_sigma[ix]}: {r2_K[ix]:.3f}\")\n    print(\"\\n\")\n\n    # run the second stage\n    RHS_proj = np.column_stack((X1_hat, K_hat))\n    betas_sigmas_est = spla.lstsq(RHS_proj, y_hat[:, 0])[0]\n    betas_est = betas_sigmas_est[:n_x1]\n    sigmas_squared_est = betas_sigmas_est[n_x1:]\n    if np.min(sigmas_squared_est) &lt; 0.0:\n        print_stars(\"\\n The variance estimates are\")\n        print(sigmas_squared_est)\n        bs_error_abort(\"Negative variance estimate!\")\n    sigmas_est = np.sqrt(sigmas_squared_est)\n\n    print_stars(\"Final estimates\")\n    for i in range(len(names_vars_beta)):\n        print(f\"   beta1_{names_vars_beta[i]}: {betas_est[i]:.3f}\")\n    for i in range(len(names_vars_sigma)):\n        print(f\"   sigma_{names_vars_sigma[i]}: {sigmas_est[i]:.3f}\")\n    return betas_est, sigmas_est\n</code></pre>"},{"location":"frac_utils.html","title":"frac_utils module","text":"<p>Utility helpers for building instruments and projections in FRAC.</p>"},{"location":"frac_utils.html#frac_blp.frac_utils.make_X","title":"<code>make_X(X_exo, X_endo)</code>","text":"<p>Combine exogenous and endogenous regressors into a single regressor matrix.</p> <p>Parameters:</p> Name Type Description Default <code>X_exo</code> <code>ndarray | None</code> <p>Exogenous regressors.</p> required <code>X_endo</code> <code>ndarray | None</code> <p>Endogenous regressors.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The concatenated regressor matrix.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>X_exo</code> and <code>X_endo</code> are <code>None</code>.</p> Source code in <code>frac_blp/frac_utils.py</code> <pre><code>def make_X(X_exo: np.ndarray | None, X_endo: np.ndarray | None) -&gt; np.ndarray:\n    \"\"\"\n    Combine exogenous and endogenous regressors into a single regressor matrix.\n\n    Args:\n        X_exo (np.ndarray | None): Exogenous regressors.\n        X_endo (np.ndarray | None): Endogenous regressors.\n\n    Returns:\n        np.ndarray: The concatenated regressor matrix.\n\n    Raises:\n        ValueError: If both `X_exo` and `X_endo` are ``None``.\n    \"\"\"\n    if X_exo is not None and X_endo is not None:\n        X = np.column_stack((X_exo, X_endo))\n    elif X_exo is not None:\n        X = X_exo\n    elif X_endo is not None:\n        X = X_endo\n    else:\n        raise ValueError(\"At least one of X_exo or X_endo must be provided.\")\n    return X\n</code></pre>"},{"location":"frac_utils.html#frac_blp.frac_utils.make_Z_full","title":"<code>make_Z_full(Z, X1_exo=None, degree_Z=2, degree_X1=2)</code>","text":"<p>Build a full set of polynomial instruments for FRAC without demographics.</p> <p>Parameters:</p> Name Type Description Default <code>Z</code> <code>ndarray</code> <p>Baseline instruments.</p> required <code>X1_exo</code> <code>ndarray | None</code> <p>Exogenous regressors without random coefficients.</p> <code>None</code> <code>degree_Z</code> <code>int</code> <p>Maximum degree applied to columns of <code>Z</code> (must be &gt;= 0).</p> <code>2</code> <code>degree_X1</code> <code>int</code> <p>Maximum degree applied to columns of <code>X1_exo</code>.</p> <code>2</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Instrument matrix whose columns enumerate every admissible</p> <code>ndarray</code> <p>combination of polynomial terms, preceded by a column of ones.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>degree_Z</code> is negative.</p> Source code in <code>frac_blp/frac_utils.py</code> <pre><code>def make_Z_full(\n    Z: np.ndarray,\n    X1_exo: np.ndarray | None = None,\n    degree_Z: int = 2,\n    degree_X1: int = 2,\n) -&gt; np.ndarray:\n    \"\"\"\n    Build a full set of polynomial instruments for FRAC without demographics.\n\n    Args:\n        Z (np.ndarray): Baseline instruments.\n        X1_exo (np.ndarray | None): Exogenous regressors without random coefficients.\n        degree_Z (int): Maximum degree applied to columns of ``Z`` (must be &gt;= 0).\n        degree_X1 (int): Maximum degree applied to columns of ``X1_exo``.\n\n    Returns:\n        np.ndarray: Instrument matrix whose columns enumerate every admissible\n        combination of polynomial terms, preceded by a column of ones.\n\n    Raises:\n        ValueError: If ``degree_Z`` is negative.\n    \"\"\"\n    if degree_Z &lt; 0:\n        raise ValueError(\"degree_Z must be non-negative.\")\n\n    n_obs, n_z = Z.shape\n    columns: list[np.ndarray] = [np.ones(n_obs)]\n\n    n_x1 = 0 if X1_exo is None else X1_exo.shape[1]\n    max_dx1 = degree_X1 if X1_exo is not None else 0\n\n    for d_z in range(degree_Z + 1):\n        z_indices = [None] if d_z == 0 else range(n_z)\n        for iz in z_indices:\n            base_z = np.ones(n_obs) if iz is None else Z[:, iz] ** d_z\n            # str_base_z = \" \" if iz is None else f\"Z[:, {iz}] ** {d_z} \"\n\n            for d_x1 in range(max_dx1 + 1):\n                x1_indices = [None] if d_x1 == 0 else range(n_x1)\n                for ix1 in x1_indices:\n                    if ix1 is None:\n                        term_x1 = np.ones(n_obs)\n                        # str_X1 = \"1 \"\n                    else:\n                        assert X1_exo is not None\n                        term_x1 = X1_exo[:, ix1] ** d_x1\n                        # str_X1 = f\"X1_exo[:, {ix1}] ** {d_x1} \"\n                    columns.append(base_z * term_x1)\n                    # print(f\"{iz=}, {d_z=}, {ix1=}, {d_x1=}\")\n                    # print(\"    \" + str_base_z + \" * \" + str_X1)\n\n    return np.column_stack(columns)\n</code></pre>"},{"location":"frac_utils.html#frac_blp.frac_utils.proj_Z_full","title":"<code>proj_Z_full(X, Z_full)</code>","text":"<p>Project each column of <code>X</code> onto <code>Z_full</code> and report fitted values.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Variables to project.</p> required <code>Z_full</code> <code>ndarray</code> <p>Instrument matrix used for the projections.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>tuple[np.ndarray, np.ndarray, np.ndarray]: <code>X_proj</code> with projected columns,</p> <code>ndarray</code> <p><code>coef</code> with least-squares coefficients, and <code>r2</code> with column-wise</p> <code>ndarray</code> <p>R-squared values.</p> Source code in <code>frac_blp/frac_utils.py</code> <pre><code>def proj_Z_full(\n    X: np.ndarray, Z_full: np.ndarray\n) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Project each column of ``X`` onto ``Z_full`` and report fitted values.\n\n    Args:\n        X (np.ndarray): Variables to project.\n        Z_full (np.ndarray): Instrument matrix used for the projections.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray, np.ndarray]: ``X_proj`` with projected columns,\n        ``coef`` with least-squares coefficients, and ``r2`` with column-wise\n        R-squared values.\n    \"\"\"\n    EPS = 1e-12\n    n_x = X.shape[1]\n    X_proj = np.empty(X.shape)\n    coef = np.empty((Z_full.shape[1], n_x))\n    r2 = np.empty(n_x)\n    for ix in range(n_x):\n        x = X[:, ix]\n        coef_x = spla.lstsq(Z_full, x)[0]\n        x_proj = Z_full @ coef_x\n        X_proj[:, ix] = x_proj\n        coef[:, ix] = coef_x\n        var_x = np.var(x)\n        r2[ix] = 1.0 if var_x &lt; EPS else np.var(x_proj) / var_x\n    return X_proj, coef, r2\n</code></pre>"},{"location":"simulate_frac_nodemog_data.html","title":"simulate_frac_nodemog_data module","text":"<p>Helper script to simulate FRAC datasets used in tutorials.</p>"},{"location":"simulate_frac_nodemog_data.html#frac_blp.simulate_frac_nodemog_data.simulate_frac_nodemog_data","title":"<code>simulate_frac_nodemog_data(params)</code>","text":"<p>Simulate FRAC data with endogenous random-coefficient regressors.</p> <p>Endogenous regressors <code>X1_k</code> are generated as follows: $$ X1_k &amp;= \\sigma_x(\\rho_{xz} z_k \\     &amp;+ \\sqrt{1 -\\rho_z ^ 2} \\     &amp;(\\rho_{x\\xi} \\xi / \\sigma_{\\xi}  +   N(0, 1-\\rho_{x\\xi}^2))) $$</p> <p>Parameters:</p> Name Type Description Default <code>FracNoDemogSimulationParameters</code> <p>parameters for the simulation.</p> required <p>Returns:</p> Name Type Description <code>FracNoDemogSimulatedData</code> <code>FracNoDemogSimulatedData</code> <p>Simulated dataset ready for FRAC estimation.</p> Source code in <code>frac_blp/simulate_frac_nodemog_data.py</code> <pre><code>def simulate_frac_nodemog_data(\n    params: FracNoDemogSimulationParameters,\n) -&gt; FracNoDemogSimulatedData:\n    \"\"\"\n    Simulate FRAC data with endogenous random-coefficient regressors.\n\n    Endogenous regressors `X1_k` are generated as follows:\n    $$\n    X1_k &amp;= \\\\sigma_x(\\\\rho_{xz} z_k \\\\\n        &amp;+ \\\\sqrt{1 -\\\\rho_z ^ 2} \\\\\n        &amp;(\\\\rho_{x\\\\xi} \\\\xi / \\\\sigma_{\\\\xi}  +   N(0, 1-\\\\rho_{x\\\\xi}^2)))\n    $$\n\n    Args:\n        FracNoDemogSimulationParameters: parameters for the simulation.\n\n    Returns:\n        FracNoDemogSimulatedData: Simulated dataset ready for FRAC estimation.\n    \"\"\"\n    T, J = (\n        params.T,\n        params.J,\n    )\n    n_obs = T * J\n    rng = np.random.default_rng(seed=None)\n    sigma_x, sigma_xi = (\n        params.sigma_x,\n        params.sigma_xi,\n    )\n    xi_var = rng.normal(0.0, sigma_xi, size=n_obs)\n    n_Z = params.n_Z\n    Z = rng.normal(0.0, 1.0, size=(n_obs, n_Z))\n    rho_xz = params.rho_xz\n    rho_x_xi = params.rho_x_xi\n    root1 = np.sqrt(1 - rho_xz**2)\n    root2 = np.sqrt(1 - rho_x_xi**2)\n    n_X1_exo, n_X1_endo, n_X2_exo, n_X2_endo = (\n        params.n_X1_exo,\n        params.n_X1_endo,\n        params.n_X2_exo,\n        params.n_X2_endo,\n    )\n    ones_vec = np.ones((n_obs, 1))\n    X1_exo = (\n        ones_vec\n        if n_X1_exo == 0\n        else np.column_stack((ones_vec, rng.normal(0.0, 1.0, size=(n_obs, n_X1_exo))))\n    )\n    X2_exo = None if n_X2_exo == 0 else X1_exo[:, :n_X2_exo]\n    X1_endo = None\n    if n_X1_endo &gt; 0:\n        X1_endo = np.zeros((n_obs, n_X1_endo))\n        for i in range(n_X1_endo):\n            X1_endo[:, i] = sigma_x * (\n                rho_xz * Z[:, i]\n                + root1\n                * (\n                    rho_x_xi * xi_var / sigma_xi\n                    + root2 * rng.normal(0.0, 1.0, size=n_obs)\n                )\n            )\n    X2_endo = None\n    if n_X2_endo &gt; 0:\n        X1_endo = cast(np.ndarray, X1_endo)\n        X2_endo = X1_endo[:, :n_X2_endo]\n    names_vars_beta = [\"constant\"] + [f\"x_{i + 1}\" for i in range(n_X1_exo + n_X1_endo)]\n    names_vars_sigma = [f\"x_{i + 1}\" for i in range(n_X2_exo + n_X2_endo)]\n\n    return FracNoDemogSimulatedData(\n        T=T,\n        J=J,\n        X1_exo=X1_exo,\n        X1_endo=X1_endo,\n        X2_exo=X2_exo,\n        X2_endo=X2_endo,\n        Z=Z,\n        xi_var=xi_var,\n        names_vars_beta=names_vars_beta,\n        names_vars_sigma=names_vars_sigma,\n        betas=params.betas,\n        sigmas=params.sigmas,\n    )\n</code></pre>"}]}