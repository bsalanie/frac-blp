{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"frac_blp","text":"<p>FRAC for macro-BLP (Salanie-Wolak).</p> <ul> <li>Github repository: https://github.com/bsalanie/frac-blp/</li> <li>Documentation https://bsalanie.github.io/frac-blp/</li> </ul>"},{"location":"index.html#overview","title":"Overview","text":"<p>The package estimates a second-order approximation to the macro BLP model with random coefficients using the FRAC method of Salanie and Wolak. </p> <p>At this early stage, the package only implements the basic version of the model without demographics. </p> <p>The user should be familiar with the macro BLP model (Berry, Levinsohn, and Pakes, 1995). We use very similar notation to that of Conlon and Gortmaker in their <code>pyblp</code> package:</p> <p>The inputs are: * <code>T</code>: the number of markets  * <code>J</code>: the number of products per market * <code>X1</code>: variables with fixed coefficients, an <code>(N=T*J, n1)</code> matrix * <code>X2</code>: variables with random coefficients, an <code>(N, n2)</code> matrix * <code>Z</code>: instruments, an <code>(N, nz)</code> matrix.</p> <p>The outputs are: * <code>betas</code>: the coefficients on the variables with fixed coefficients and the mean coefficients on the variables with random coefficients, an <code>(n1 + n2)</code> vector * <code>sigmas</code>: the standard deviations of the coefficients on the variables with random coefficients, an <code>n2</code> vector.</p>"},{"location":"index.html#entering-the-data","title":"entering the data","text":"<p>The user must provide the data as numpy arrays with <code>T*J</code> rows:</p> <ul> <li> <p><code>X1_exo, X1_endo, X2_exo, X2_endo</code>: matrices of exogenous and endogenous variables with fixed and random coefficients</p> </li> <li> <p><code>Z</code>: matrix of instruments</p> </li> <li> <p><code>shares</code>: vector of market shares.</p> </li> </ul> <p>The observations should be ordered by market, i.e., the first <code>J</code> rows correspond to market 1, the next <code>J</code> rows to market 2, etc.</p> <p>These are entered in the model as follows: <pre><code>rom frac blp.frac classes import FracNodemogRealData\n\nfrac data = FracNodemogRealData(T, J,\n                            X1_exo, X1_endo,\n                            X2_exo, X2_endo,\n                            Z, shares,\n                            names_vars_beta,\n                            names_vars_sigma)\n</code></pre> Then the model can be estimated with: <pre><code>from frac_blp.frac_nodemog import estimate\n\nbetabar, sigmas = frac nodemog estimate(frac data)\n</code></pre></p>"},{"location":"index.html#release-notes","title":"Release notes","text":""},{"location":"index.html#01-october-26-2025","title":"0.1 (October 26, 2025)","text":"<p>First working version, no demographics.</p>"},{"location":"artificial_regressors.html","title":"artificial_regressors module","text":"<p>Helpers to construct Salani\u00e9-Wolak artificial regressors.</p>"},{"location":"artificial_regressors.html#frac_blp.artificial_regressors.make_K","title":"<code>make_K(X, shares)</code>","text":"<p>Build second-order Salani\u00e9-Wolak artificial regressors.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Product characteristics of shape <code>(n_products, n_x)</code>.</p> required <code>shares</code> <code>ndarray</code> <p>Product-level market shares of shape <code>(n_products,)</code>.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Matrix <code>K</code> with shape <code>(n_products, n_x)</code>.</p> Source code in <code>frac_blp/artificial_regressors.py</code> <pre><code>def make_K(X: np.ndarray, shares: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Build second-order Salani\u00e9-Wolak artificial regressors.\n\n    Args:\n        X (np.ndarray): Product characteristics of shape ``(n_products, n_x)``.\n        shares (np.ndarray): Product-level market shares of shape ``(n_products,)``.\n\n    Returns:\n        np.ndarray: Matrix ``K`` with shape ``(n_products, n_x)``.\n    \"\"\"\n    eS_X = X.T @ shares\n    djm = eS_X - X / 2.0\n    return cast(np.ndarray, -djm * X)\n</code></pre>"},{"location":"artificial_regressors.html#frac_blp.artificial_regressors.make_K_and_y","title":"<code>make_K_and_y(X2, shares, J)</code>","text":"<p>Construct second-order regressors and the log-share LHS by market.</p> <p>Parameters:</p> Name Type Description Default <code>X2</code> <code>ndarray</code> <p>Regressors with random coefficients.</p> required <code>shares</code> <code>ndarray</code> <p>Observed market shares.</p> required <code>J</code> <code>int</code> <p>Number of products per market.</p> required <p>Returns:</p> Name Type Description <code>TwoArrays</code> <code>TwoArrays</code> <p><code>(K, y)</code> where <code>K</code> are artificial regressors and <code>y</code> is the</p> <code>TwoArrays</code> <p>stacked log share ratios.</p> Source code in <code>frac_blp/artificial_regressors.py</code> <pre><code>def make_K_and_y(X2: np.ndarray, shares: np.ndarray, J: int) -&gt; TwoArrays:\n    \"\"\"\n    Construct second-order regressors and the log-share LHS by market.\n\n    Args:\n        X2 (np.ndarray): Regressors with random coefficients.\n        shares (np.ndarray): Observed market shares.\n        J (int): Number of products per market.\n\n    Returns:\n        TwoArrays: ``(K, y)`` where ``K`` are artificial regressors and ``y`` is the\n        stacked log share ratios.\n    \"\"\"\n    n_obs = X2.shape[0]\n    n_x2 = X2.shape[1]\n    K = np.zeros((n_obs, n_x2))  # the artificial Salanie-Wolak regressors\n    y = np.zeros(n_obs)  # and the regression LHS\n\n    for t in range(n_obs // J):\n        this_market = slice(t * J, (t + 1) * J)\n        these_shares = shares[this_market]\n        sum_shares = these_shares.sum()\n        this_market_zero_share = 1.0 - sum_shares\n        this_X2 = X2[this_market, :]\n\n        # artificial regressors and LHS for Salanie-Wolak\n        K[this_market, :] = make_K(this_X2, these_shares)\n        y[this_market] = np.log(these_shares / this_market_zero_share)\n    return K, y\n</code></pre>"},{"location":"example_frac_nodemog.html","title":"examples/example_frac_nodemog module","text":"<p>Executable example demonstrating FRAC estimation without demographics.</p>"},{"location":"example_frac_nodemog.html#frac_blp.examples.example_frac_nodemog.run_example","title":"<code>run_example()</code>","text":"<p>Run the FRAC estimation example on simulated data.</p> Source code in <code>frac_blp/examples/example_frac_nodemog.py</code> <pre><code>def run_example():\n    \"\"\"Run the FRAC estimation example on simulated data.\"\"\"\n    print(\"Hello from fracblp!\")\n    frac_data = simulate_frac_nodemog_data(\n        T=50,\n        J=20,\n    )\n    print(frac_data)\n\n    print_stars(\"Estimating with FRAC\")\n    _, _ = frac_nodemog_estimate(frac_data)\n</code></pre>"},{"location":"frac_classes.html","title":"frac_classes module","text":"<p>Data containers used by FRAC estimators.</p>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogRealData","title":"<code>FracNoDemogRealData</code>  <code>dataclass</code>","text":"<p>Container for real FRAC data without demographics.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>@dataclass\nclass FracNoDemogRealData:\n    \"\"\"Container for real FRAC data without demographics.\"\"\"\n\n    T: int\n    J: int\n    X1_exo: np.ndarray | None\n    X1_endo: np.ndarray | None\n    X2_exo: np.ndarray | None\n    X2_endo: np.ndarray | None\n    Z: np.ndarray\n    names_vars_beta: list[str]\n    names_vars_sigma: list[str]\n    shares: np.ndarray\n\n    X1: np.ndarray = field(init=False)\n    X2: np.ndarray = field(init=False)\n    n_obs: int = field(init=False)\n\n    def __post_init__(self):\n        \"\"\"Compute derived attributes once inputs are provided.\"\"\"\n        self.n_obs = self.T * self.J\n        self.X1 = make_X(self.X1_exo, self.X1_endo)\n        self.X2 = make_X(self.X2_exo, self.X2_endo)\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a text summary of the observed dataset.\n\n        Returns:\n            str: Multi-line description with key parameters.\n        \"\"\"\n        desc = \"Observed Data for FRAC w/o demographics:\\n\"\n        desc += f\"  Number of markets (T): {self.T}\\n\"\n        desc += f\"  Products per market (J): {self.J}\\n\"\n        desc += (\n            f\"  Names of variables with fixed coefficients: {self.names_vars_beta}\\n\"\n        )\n        desc += (\n            f\"  Names of variables with random coefficients: {self.names_vars_sigma}\\n\"\n        )\n        return desc\n</code></pre>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogRealData.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Compute derived attributes once inputs are provided.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Compute derived attributes once inputs are provided.\"\"\"\n    self.n_obs = self.T * self.J\n    self.X1 = make_X(self.X1_exo, self.X1_endo)\n    self.X2 = make_X(self.X2_exo, self.X2_endo)\n</code></pre>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogRealData.__str__","title":"<code>__str__()</code>","text":"<p>Return a text summary of the observed dataset.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Multi-line description with key parameters.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return a text summary of the observed dataset.\n\n    Returns:\n        str: Multi-line description with key parameters.\n    \"\"\"\n    desc = \"Observed Data for FRAC w/o demographics:\\n\"\n    desc += f\"  Number of markets (T): {self.T}\\n\"\n    desc += f\"  Products per market (J): {self.J}\\n\"\n    desc += (\n        f\"  Names of variables with fixed coefficients: {self.names_vars_beta}\\n\"\n    )\n    desc += (\n        f\"  Names of variables with random coefficients: {self.names_vars_sigma}\\n\"\n    )\n    return desc\n</code></pre>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogSimulatedData","title":"<code>FracNoDemogSimulatedData</code>  <code>dataclass</code>","text":"<p>Container for simulated FRAC data without demographics.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>@dataclass\nclass FracNoDemogSimulatedData:\n    \"\"\"Container for simulated FRAC data without demographics.\"\"\"\n\n    T: int\n    J: int\n    X1_exo: np.ndarray | None\n    X1_endo: np.ndarray | None\n    X2_exo: np.ndarray | None\n    X2_endo: np.ndarray | None\n    xi_var: np.ndarray\n    Z: np.ndarray\n    names_vars_beta: list[str]\n    names_vars_sigma: list[str]\n    betas: np.ndarray\n    sigmas: np.ndarray\n\n    shares: np.ndarray = field(init=False)\n    X1: np.ndarray = field(init=False)\n    X2: np.ndarray = field(init=False)\n    n_obs: int = field(init=False)\n\n    def __post_init__(self):\n        \"\"\"Populate derived arrays and simulate shares.\"\"\"\n        self.n_obs = self.T * self.J\n        self.X1 = make_X(self.X1_exo, self.X1_endo)\n        self.X2 = make_X(self.X2_exo, self.X2_endo)\n        self.shares = self.compute_shares()\n\n    def compute_shares(self) -&gt; np.ndarray:\n        \"\"\"\n        Simulate market shares via sparse Gaussian quadrature.\n\n        Returns:\n            np.ndarray: Simulated shares stacked across all markets.\n        \"\"\"\n        T, J = self.T, self.J\n        sigmas = self.sigmas\n        sigma = sigmas[0]\n        n_obs = T * J\n        X2 = self.X2\n        n_x2 = X2.shape[1]\n        mean_utils = self.X1 @ self.betas + self.xi_var.reshape(n_obs)\n        shares = np.zeros(n_obs)\n        nodes, weights = setup_sparse_gaussian(n_x2, 17)\n        nodes_T = nodes.T\n        zero_share = np.zeros(self.T)\n        for t in range(T):\n            this_market = slice(t * J, (t + 1) * J)\n            these_mean_utils = mean_utils[this_market]\n            this_X2 = X2[this_market, :]\n\n            def shares_random(eps_vals):\n                randoms = sigma * np.outer(this_X2, eps_vals)\n                randoms = this_X2 @ (nodes_T * sigmas.reshape((-1, 1)))\n                random_utils = randoms + these_mean_utils.reshape((-1, 1))\n                max_util = np.max(random_utils, axis=0)\n                shifted_utils = random_utils - max_util\n                exp_utils = np.exp(shifted_utils)\n                denom = np.exp(-max_util) + np.sum(exp_utils, axis=0)\n                return exp_utils / denom\n\n            shares[this_market] = shares_random(nodes) @ weights\n            zero_share[t] = 1.0 - shares[this_market].sum()\n\n        print_stars(\n            f\"\"\"\n                    Data generation completed; the average zero share is {zero_share.mean():.4f}\n                    \"\"\"\n        )\n        return shares\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a text summary of the simulated dataset.\n\n        Returns:\n            str: Multi-line description with key parameters.\n        \"\"\"\n        desc = \"Simulated Data for FRAC w/o demographics:\\n\"\n        desc += f\"  Number of markets (T): {self.T}\\n\"\n        desc += f\"  Products per market (J): {self.J}\\n\"\n        desc += (\n            f\"  Names of variables with fixed coefficients: {self.names_vars_beta}\\n\"\n        )\n        desc += (\n            f\"  Names of variables with random coefficients: {self.names_vars_sigma}\\n\"\n        )\n        desc += f\"  Betas: {self.betas}\\n\"\n        desc += f\"  Sigmas: {self.sigmas}\\n\"\n        return desc\n</code></pre>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogSimulatedData.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Populate derived arrays and simulate shares.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Populate derived arrays and simulate shares.\"\"\"\n    self.n_obs = self.T * self.J\n    self.X1 = make_X(self.X1_exo, self.X1_endo)\n    self.X2 = make_X(self.X2_exo, self.X2_endo)\n    self.shares = self.compute_shares()\n</code></pre>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogSimulatedData.__str__","title":"<code>__str__()</code>","text":"<p>Return a text summary of the simulated dataset.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Multi-line description with key parameters.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return a text summary of the simulated dataset.\n\n    Returns:\n        str: Multi-line description with key parameters.\n    \"\"\"\n    desc = \"Simulated Data for FRAC w/o demographics:\\n\"\n    desc += f\"  Number of markets (T): {self.T}\\n\"\n    desc += f\"  Products per market (J): {self.J}\\n\"\n    desc += (\n        f\"  Names of variables with fixed coefficients: {self.names_vars_beta}\\n\"\n    )\n    desc += (\n        f\"  Names of variables with random coefficients: {self.names_vars_sigma}\\n\"\n    )\n    desc += f\"  Betas: {self.betas}\\n\"\n    desc += f\"  Sigmas: {self.sigmas}\\n\"\n    return desc\n</code></pre>"},{"location":"frac_classes.html#frac_blp.frac_classes.FracNoDemogSimulatedData.compute_shares","title":"<code>compute_shares()</code>","text":"<p>Simulate market shares via sparse Gaussian quadrature.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Simulated shares stacked across all markets.</p> Source code in <code>frac_blp/frac_classes.py</code> <pre><code>def compute_shares(self) -&gt; np.ndarray:\n    \"\"\"\n    Simulate market shares via sparse Gaussian quadrature.\n\n    Returns:\n        np.ndarray: Simulated shares stacked across all markets.\n    \"\"\"\n    T, J = self.T, self.J\n    sigmas = self.sigmas\n    sigma = sigmas[0]\n    n_obs = T * J\n    X2 = self.X2\n    n_x2 = X2.shape[1]\n    mean_utils = self.X1 @ self.betas + self.xi_var.reshape(n_obs)\n    shares = np.zeros(n_obs)\n    nodes, weights = setup_sparse_gaussian(n_x2, 17)\n    nodes_T = nodes.T\n    zero_share = np.zeros(self.T)\n    for t in range(T):\n        this_market = slice(t * J, (t + 1) * J)\n        these_mean_utils = mean_utils[this_market]\n        this_X2 = X2[this_market, :]\n\n        def shares_random(eps_vals):\n            randoms = sigma * np.outer(this_X2, eps_vals)\n            randoms = this_X2 @ (nodes_T * sigmas.reshape((-1, 1)))\n            random_utils = randoms + these_mean_utils.reshape((-1, 1))\n            max_util = np.max(random_utils, axis=0)\n            shifted_utils = random_utils - max_util\n            exp_utils = np.exp(shifted_utils)\n            denom = np.exp(-max_util) + np.sum(exp_utils, axis=0)\n            return exp_utils / denom\n\n        shares[this_market] = shares_random(nodes) @ weights\n        zero_share[t] = 1.0 - shares[this_market].sum()\n\n    print_stars(\n        f\"\"\"\n                Data generation completed; the average zero share is {zero_share.mean():.4f}\n                \"\"\"\n    )\n    return shares\n</code></pre>"},{"location":"frac_nodemog.html","title":"frac_nodemog module","text":"<p>FRAC estimation on macro-BLP, without demographics</p>"},{"location":"frac_nodemog.html#frac_blp.frac_nodemog.frac_nodemog_estimate","title":"<code>frac_nodemog_estimate(frac_data)</code>","text":"<p>Estimate FRAC parameters without demographics using two-stage least squares.</p> <p>Parameters:</p> Name Type Description Default <code>frac_data</code> <code>FracNoDemogData</code> <p>Data container with regressors, instruments, and simulated or empirical shares.</p> required <p>Returns:</p> Name Type Description <code>TwoArrays</code> <code>TwoArrays</code> <p>Tuple <code>(betas_est, sigmas_est)</code> with fixed and random coefficient</p> <code>TwoArrays</code> <p>estimates, respectively.</p> Source code in <code>frac_blp/frac_nodemog.py</code> <pre><code>def frac_nodemog_estimate(\n    frac_data: FracNoDemogData,\n) -&gt; TwoArrays:\n    \"\"\"\n    Estimate FRAC parameters without demographics using two-stage least squares.\n\n    Args:\n        frac_data (FracNoDemogData): Data container with regressors, instruments, and\n            simulated or empirical shares.\n\n    Returns:\n        TwoArrays: Tuple ``(betas_est, sigmas_est)`` with fixed and random coefficient\n        estimates, respectively.\n    \"\"\"\n    X1_exo = frac_data.X1_exo\n    X2_exo = frac_data.X2_exo\n    X1, X2 = frac_data.X1, frac_data.X2\n    J = frac_data.J\n    Z = frac_data.Z\n    names_vars_beta = frac_data.names_vars_beta\n    names_vars_sigma = frac_data.names_vars_sigma\n    shares = frac_data.shares\n    K, y = make_K_and_y(X2, shares, J)\n    n_x1 = X1.shape[1]\n    n_x2 = X2.shape[1]\n\n    # combine exogenous regressors and instruments\n    Z_full = make_Z_full(Z, X1_exo, X2_exo, degree_Z=3, degree_X1=2, degree_X2=2)\n\n    # project on the full set of instruments\n    y_hat, _, r2_y = proj_Z_full(y.reshape((-1, 1)), Z_full)\n    K_hat, _, r2_K = proj_Z_full(K, Z_full)\n    X1_hat, _, r2_X1 = proj_Z_full(X1, Z_full)\n\n    print_stars(\"The first stage R2s are:\")\n    print(f\"   (using {Z_full.shape[1]} instruments)\")\n    print(f\"     y: {r2_y[0]:.3f}\")\n    for ix in range(n_x1):\n        print(f\"     {names_vars_beta[ix]}: {r2_X1[ix]:.3f}\")\n    for ix in range(n_x2):\n        print(f\"     K_{names_vars_sigma[ix]}: {r2_K[ix]:.3f}\")\n    print(\"\\n\")\n\n    # run the second stage\n    RHS_proj = np.column_stack((X1_hat, K_hat))\n    betas_sigmas_est = spla.lstsq(RHS_proj, y_hat[:, 0])[0]\n    betas_est = betas_sigmas_est[:n_x1]\n    sigmas_squared_est = betas_sigmas_est[n_x1:]\n    if np.min(sigmas_squared_est) &lt; 0.0:\n        print(\"\\n The variance estimates are\")\n        print(sigmas_squared_est)\n        bs_error_abort(\"Negative variance estimate!\")\n    sigmas_est = np.sqrt(sigmas_squared_est)\n\n    print_stars(\"Final estimates\")\n    for i in range(len(names_vars_beta)):\n        print(f\"   beta1_{names_vars_beta[i]}: {betas_est[i]:.3f}\")\n    for i in range(len(names_vars_sigma)):\n        print(f\"   sigma_{names_vars_sigma[i]}: {sigmas_est[i]:.3f}\")\n    return betas_est, sigmas_est\n</code></pre>"},{"location":"frac_utils.html","title":"frac_utils module","text":"<p>Utility helpers for building instruments and projections in FRAC.</p>"},{"location":"frac_utils.html#frac_blp.frac_utils.make_X","title":"<code>make_X(X_exo, X_endo)</code>","text":"<p>Combine exogenous and endogenous regressors into a single regressor matrix.</p> <p>Parameters:</p> Name Type Description Default <code>X_exo</code> <code>ndarray | None</code> <p>Exogenous regressors.</p> required <code>X_endo</code> <code>ndarray | None</code> <p>Endogenous regressors.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The concatenated regressor matrix.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>X_exo</code> and <code>X_endo</code> are <code>None</code>.</p> Source code in <code>frac_blp/frac_utils.py</code> <pre><code>def make_X(X_exo: np.ndarray | None, X_endo: np.ndarray | None) -&gt; np.ndarray:\n    \"\"\"\n    Combine exogenous and endogenous regressors into a single regressor matrix.\n\n    Args:\n        X_exo (np.ndarray | None): Exogenous regressors.\n        X_endo (np.ndarray | None): Endogenous regressors.\n\n    Returns:\n        np.ndarray: The concatenated regressor matrix.\n\n    Raises:\n        ValueError: If both `X_exo` and `X_endo` are ``None``.\n    \"\"\"\n    if X_exo is not None and X_endo is not None:\n        X = np.column_stack((X_exo, X_endo))\n    elif X_exo is not None:\n        X = X_exo\n    elif X_endo is not None:\n        X = X_endo\n    else:\n        raise ValueError(\"At least one of X_exo or X_endo must be provided.\")\n    return X\n</code></pre>"},{"location":"frac_utils.html#frac_blp.frac_utils.make_Z_full","title":"<code>make_Z_full(Z, X1_exo=None, X2_exo=None, degree_Z=1, degree_X1=0, degree_X2=0)</code>","text":"<p>Build a full set of polynomial instruments for FRAC without demographics.</p> <p>Parameters:</p> Name Type Description Default <code>Z</code> <code>ndarray</code> <p>Baseline instruments.</p> required <code>X1_exo</code> <code>ndarray | None</code> <p>Exogenous regressors without random coefficients.</p> <code>None</code> <code>X2_exo</code> <code>ndarray | None</code> <p>Exogenous regressors with random coefficients.</p> <code>None</code> <code>degree_Z</code> <code>int</code> <p>Maximum degree applied to columns of <code>Z</code> (must be &gt;= 0).</p> <code>1</code> <code>degree_X1</code> <code>int</code> <p>Maximum degree applied to columns of <code>X1_exo</code>.</p> <code>0</code> <code>degree_X2</code> <code>int</code> <p>Maximum degree applied to columns of <code>X2_exo</code>.</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Instrument matrix whose columns enumerate every admissible</p> <code>ndarray</code> <p>combination of polynomial terms, preceded by a column of ones.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>degree_Z</code> is negative.</p> Source code in <code>frac_blp/frac_utils.py</code> <pre><code>def make_Z_full(\n    Z: np.ndarray,\n    X1_exo: np.ndarray | None = None,\n    X2_exo: np.ndarray | None = None,\n    degree_Z: int = 1,\n    degree_X1: int = 0,\n    degree_X2: int = 0,\n) -&gt; np.ndarray:\n    \"\"\"\n    Build a full set of polynomial instruments for FRAC without demographics.\n\n    Args:\n        Z (np.ndarray): Baseline instruments.\n        X1_exo (np.ndarray | None): Exogenous regressors without random coefficients.\n        X2_exo (np.ndarray | None): Exogenous regressors with random coefficients.\n        degree_Z (int): Maximum degree applied to columns of ``Z`` (must be &gt;= 0).\n        degree_X1 (int): Maximum degree applied to columns of ``X1_exo``.\n        degree_X2 (int): Maximum degree applied to columns of ``X2_exo``.\n\n    Returns:\n        np.ndarray: Instrument matrix whose columns enumerate every admissible\n        combination of polynomial terms, preceded by a column of ones.\n\n    Raises:\n        ValueError: If ``degree_Z`` is negative.\n    \"\"\"\n    if degree_Z &lt; 0:\n        raise ValueError(\"degree_Z must be non-negative.\")\n\n    n_obs, n_z = Z.shape\n    columns: list[np.ndarray] = [np.ones(n_obs)]\n\n    n_x1 = 0 if X1_exo is None else X1_exo.shape[1]\n    n_x2 = 0 if X2_exo is None else X2_exo.shape[1]\n\n    max_dx1 = degree_X1 if X1_exo is not None else 0\n    max_dx2 = degree_X2 if X2_exo is not None else 0\n\n    for d_z in range(degree_Z + 1):\n        z_indices = [None] if d_z == 0 else range(n_z)\n        for iz in z_indices:\n            base_z = np.ones(n_obs) if iz is None else Z[:, iz] ** d_z\n\n            for d_x1 in range(max_dx1 + 1):\n                x1_indices = [None] if d_x1 == 0 else range(n_x1)\n                for ix1 in x1_indices:\n                    if ix1 is None:\n                        term_x1 = np.ones(n_obs)\n                    else:\n                        assert X1_exo is not None\n                        term_x1 = X1_exo[:, ix1] ** d_x1\n\n                    for d_x2 in range(max_dx2 + 1):\n                        x2_indices = [None] if d_x2 == 0 else range(n_x2)\n                        for ix2 in x2_indices:\n                            if d_z == d_x1 == d_x2 == 0:\n                                continue  # ones already included\n\n                            if ix2 is None:\n                                term_x2 = np.ones(n_obs)\n                            else:\n                                assert X2_exo is not None\n                                term_x2 = X2_exo[:, ix2] ** d_x2\n                            columns.append(base_z * term_x1 * term_x2)\n\n    return np.column_stack(columns)\n</code></pre>"},{"location":"frac_utils.html#frac_blp.frac_utils.proj_Z_full","title":"<code>proj_Z_full(X, Z_full)</code>","text":"<p>Project each column of <code>X</code> onto <code>Z_full</code> and report fitted values.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Variables to project.</p> required <code>Z_full</code> <code>ndarray</code> <p>Instrument matrix used for the projections.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>tuple[np.ndarray, np.ndarray, np.ndarray]: <code>X_proj</code> with projected columns,</p> <code>ndarray</code> <p><code>coef</code> with least-squares coefficients, and <code>r2</code> with column-wise</p> <code>ndarray</code> <p>R-squared values.</p> Source code in <code>frac_blp/frac_utils.py</code> <pre><code>def proj_Z_full(\n    X: np.ndarray, Z_full: np.ndarray\n) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Project each column of ``X`` onto ``Z_full`` and report fitted values.\n\n    Args:\n        X (np.ndarray): Variables to project.\n        Z_full (np.ndarray): Instrument matrix used for the projections.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray, np.ndarray]: ``X_proj`` with projected columns,\n        ``coef`` with least-squares coefficients, and ``r2`` with column-wise\n        R-squared values.\n    \"\"\"\n    EPS = 1e-12\n    n_x = X.shape[1]\n    X_proj = np.empty(X.shape)\n    coef = np.empty((Z_full.shape[1], n_x))\n    r2 = np.empty(n_x)\n    for ix in range(n_x):\n        x = X[:, ix]\n        coef_x = spla.lstsq(Z_full, x)[0]\n        x_proj = Z_full @ coef_x\n        X_proj[:, ix] = x_proj\n        coef[:, ix] = coef_x\n        var_x = np.var(x)\n        r2[ix] = 1.0 if var_x &lt; EPS else np.var(x_proj) / var_x\n    return X_proj, coef, r2\n</code></pre>"},{"location":"simulate_frac_nodemog_data.html","title":"simulate_frac_nodemog_data module","text":"<p>Helper script to simulate FRAC datasets used in tutorials.</p>"},{"location":"simulate_frac_nodemog_data.html#frac_blp.simulate_frac_nodemog_data.simulate_frac_nodemog_data","title":"<code>simulate_frac_nodemog_data(T, J)</code>","text":"<p>Simulate FRAC data with endogenous random-coefficient regressors.</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>int</code> <p>Number of markets.</p> required <code>J</code> <code>int</code> <p>Number of products per market.</p> required <p>Returns:</p> Name Type Description <code>FracNoDemogSimulatedData</code> <code>FracNoDemogSimulatedData</code> <p>Simulated dataset ready for FRAC estimation.</p> Source code in <code>frac_blp/simulate_frac_nodemog_data.py</code> <pre><code>def simulate_frac_nodemog_data(T: int, J: int) -&gt; FracNoDemogSimulatedData:\n    \"\"\"\n    Simulate FRAC data with endogenous random-coefficient regressors.\n\n    Args:\n        T (int): Number of markets.\n        J (int): Number of products per market.\n\n    Returns:\n        FracNoDemogSimulatedData: Simulated dataset ready for FRAC estimation.\n    \"\"\"\n    n_obs = T * J\n    rng = np.random.default_rng(seed=None)\n    xi_var = rng.normal(0.0, 1.0, size=(n_obs, 1))\n    Z = rng.normal(0.0, 1.0, size=(n_obs, 1))\n    rho_xz = np.sqrt(0.5)\n    rho_x_xi = np.sqrt(0.5)\n    x_var = rho_xz * Z + np.sqrt(1.0 - rho_xz**2) * (\n        rho_x_xi * xi_var\n        + np.sqrt(1.0 - rho_x_xi**2) * rng.normal(0.0, 1.0, size=(n_obs, 1))\n    )\n    X1_exo = np.ones((n_obs, 1))\n    X1_endo = x_var.reshape((n_obs, 1))\n    X2_exo = None\n    X2_endo = x_var.reshape((n_obs, 1))\n\n    betas = np.array([-4.3, 1.0])\n    sigmas = np.array([1.0])\n    names_vars_beta1 = [\"constant\", \"x\"]\n    names_vars_sigma = [\"x\"]\n\n    return FracNoDemogSimulatedData(\n        T=T,\n        J=J,\n        X1_exo=X1_exo,\n        X1_endo=X1_endo,\n        X2_exo=X2_exo,\n        X2_endo=X2_endo,\n        Z=Z,\n        xi_var=xi_var,\n        names_vars_beta=names_vars_beta1,\n        names_vars_sigma=names_vars_sigma,\n        betas=betas,\n        sigmas=sigmas,\n    )\n</code></pre>"}]}